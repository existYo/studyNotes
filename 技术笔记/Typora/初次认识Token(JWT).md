#### JWT(Json Web Token)

##### 1.含义

JWT是一个开放的行业标准（RFC 7519），它定义了一种简洁的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公 钥/私钥对来签名，防止被篡改。

体验 Json  Web Token。网址：[在线生成JWT](https://jwt.io/)

##### 2.比较

###### 传统Token

传统的token是某个用户登陆之后，服务器返回一个token给用户保存，这个token可能是随机几个字母的组合，并且服务器保留同一份token(比如用redis存储token)

当用户对其他的接口访问时，必须携带这个token，接着服务器判断这个token是否存在与redis中，来判断用户是否已经登陆或者是否有相应的权限

###### JWT

与传统token不同的是，json web token是不用保留一份在服务器上的。

处理流程：

用户登陆之后，服务器通过计算，返回一个按照一定规则加密过的token，token里面包含用户的一些必要信息，比如用户的id、token过期时间

当用户访问其他的接口时，必须携带这个token，接着服务器通过密码来验证这个token

-   验证token是否是服务器发送的token
-   验证token过期时间

一切都正确之后，才认为用户是已经登陆、有相应权限的

##### 3.优点

(1)jwt基于json，非常方便解析。

(2)可以在令牌中自定义丰富的内容，易扩展。

(3)通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。

(4)资源服务使用JWT可不依赖认证服务即可完成授权。

(5)可以手机端、web端、小程序端等等使用.

##### 4.缺点

(1)JWT令牌较长，占存储空间比较大。

(2)生成和解析token都需要时间，对比于传统的token验证方式，JWT的生成与解析花的时间会比较多。

##### 5.令牌的结构

![JWT结构](https://cdn.hicaiji.com/halo/JWT_structure_1603373585781.png?image/auto-orient,1/resize,m_lfit,w_200/quality,q_90)

 令牌包含三部分，头部、载荷、签名，每部分中间使用点（.）分隔

(1)Header(头部)

头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）。比如：

~~~java
{
	"alg": "HS256",
	"typ": "JWT"
}
~~~

将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。

**注意**（base64加密后的数据是任何人都可以解密，相当于透明）。

(2)Payload(载荷)

第二部分是载荷，内容是一个json对象，它是存放有效信息的地方。它可以存放以下三种类型：

<1>`Reserved`（保留声明），它的含义就像是编程语言的保留字一样，属于JWT规范中规定好的，这类声明不是必须的，但是是建议使用的。有以下几种：
iss: JWT的签发者

sub: 该JWT所面向的用户

aud:JWT的接收方

exp(expires): 过期时间，这里是一个Unix时间戳

iat(issued at): 签发时间，这里是一个Unix时间戳

Unix时间戳是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。

<2>`Public`(公共声明)：这类声明需要在 [IANA JSON Web Token Registry](http://www.iana.org/assignments/jwt/jwt.xhtml) 中定义或者提供一个URI，因为要避免重名等冲突。

<3>`Private`（私有声明）：根据业务需要自己定义的数据

载荷数据，比如：

~~~java
{
	"iss": "Jitwxs",
	"iat": 1441593502,
	"exp": 1441594722,
	"aud": "www.example.com",
	"sub": "wxs@example.com",
	"user_id":"10001"
}
~~~

将以上数据使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分，同样不安全，不建议存放敏感数据。

(3)Signature(签名)

第三部分是签名，此部分用于防止jwt内容被篡改。

这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明签名算法进行签名。如果是哈希加密，哈希加密是需要密码的，这个密码不能透露给用户，也就是加密后的内容是不可逆的。比如：

~~~java

HMACSHA256(
	base64UrlEncode(header) + "." + base64UrlEncode(payload),secret
)
~~~

base64UrlEncode(header)：jwt令牌的第一部分。
base64UrlEncode(payload)：jwt令牌的第二部分。
secret：签名所使用的密钥。

什么意思呢？

**比如**头部部分记录的是7点创建，8点过期，即有效期一个小时。

数据部分记录的是某个用户的id。

这个时候服务器通过密码加密之后，会形成一串字符串（只要头部和数据部分的数据不改变，那么每次加密都会形成一样的字符串）

你7-8点之间访问服务接口都可以正常使用

**然而**，9点钟的时候，黑客发现了你这个token，不过token已经过期，然后黑客改了头部的过期时间，然后再用这个token来访问服务接口

这时候就会出错，为什么呢？

**因为**头部的信息改动之后，签名就会改变，然而黑客没有生成token的密码，使用黑客不能构造正确的签名

后台验证token的时候，会把头部和数据部分进行用密码加密，生成一个签名，然后再与提交上来的token对比是否一致



#### 生成JWT

